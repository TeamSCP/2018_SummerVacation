# Handle Hijacking

> 해당 기술은 UC 포럼의 `harakrinox`의 글을 참조 하였습니다.

## 읽기 전..
  
  - 프로세스간 통신(IPC)중 Named Pipe를 사용합니다.
  - `공격 대상 프로세스가 핸들을 구해 올 수 없다`의 가정 하에 진행 됩니다.
  - `개념증명(PoC)`에 사용 되는 코드는 대상이 둘 다 실행 파일이지만, 파이프 서버쪽을 `하이재킹 대상` 혹은 `dll injection`의 대상이라고 생각 해주세요.
  - 유저 모드에서 사용 되는 우회 기법입니다.

## 하이재킹?

개념은 아주 간단합니다. 이미 사용되고 있는 무언가(세션, 쿠키, 핸들 ···)를 가져와 사용 하는 것입니다.
<br>참조 링크: https://en.wikipedia.org/wiki/Hijacking

## 핸들에 대해 복습

프로세스, 파일 같은 것들은 모두 커널에서 사용되는 객체입니다.<br>이러한 객체를 유저모드에서 접근 하기 위해서 객체에 대한 인스턴스를 만들어주고,<br>
인스턴스에 대해 접근 할 수 있는 방법이 핸들인 것입니다.

## 핸들을 빌려 쓰는 것이 왜 우회인가요?
오래 전(중학교~대학교 1학년)에는 공격 대상이 타겟 프로세스인 경우가 많았습니다.<br>
RPM/WPM으로 메모리를 읽기/쓰기를 하던, Dll을 인젝션을 하여 코드를 수정하던, 그 프로세스에 대한 핸들을 직접 가져 오는 것이였습니다.<br>
그렇다면 Anti-Cheat 개발자 분들은 타겟 프로세스에 대한 핸들을 얻어 오지 못하게 하려는 작업을 해두지 않을까요?<br>

## 가능합니다!
<img src="https://user-images.githubusercontent.com/40850499/42858623-6f81303a-8a8a-11e8-88f3-90f182cab2bd.png"/>
이미지를 참조하시면 특정 프로세스에서 타겟 프로세스에 대한 핸들을 가지고 있습니다.
이미 가지고 있는 프로세스에 대해 dll을 주입 한 뒤, dll을 실제 명령을 시행하는 서버로 두고 명령을 내리는 클라이언트를 만들어주면,
타겟 프로세스에 직접 접근하는 코드는 없어 지는 것이죠.

## 프로세스 간 통신(Inter-Process Communication, IPC)

프로세스간 통신방법에는 아래와 같이 많은 방법이 있습니다.
  - File (*)
  - Anonymous Pipe
  - Named Pipe
  - Socket (*)
  - Shared Memory
  - Memory Mapped File
  - Windows Message (*)
  
위의 이미지의 서버가 되는 부분에는 Dll Injection되어 타겟 프로세스의 핸들 정보를 가지고 있을 것입니다.<br>
이 상태에서 클라이언트 측에서 명령을 요청하면 서버는 알아 듣고 해당 작업을 해주어야 합니다.
즉, 서버-클라이언트 혹은 프로세스간의 통신을 할 수 있는 방법이 필요하게됩니다.
여기서 *가 되어있는 부분은 제가 사용 해봤던 IPC 방법입니다.
이번 기술문서에서는 Named Pipe(이름있는 파이프)를 사용하여 서버-클라이언트간의 원격명령을 시행 하는 것을 최종목표로 두고 있습니다.

## IPC중 Named Pipe 설명

- 소켓 프로그래밍 해봤다면.. 나름 이해 가는듯?

## 1. 테스트 프로그램 작성(타겟 프로그램)
  - 간단히 Int, String 타입의 변수의 상태를 확인 할 수 있는 프로그램
## 2. 테스트 프로그램 작성(파이프 서버(하이재킹 대상))
  - 하이재킹 대상 ( CreateNamedPipe, ConnectNamedPipe, OpenProcess로 타겟 프로그램에 대한 핸들을 받아옴. 여기서는 lsass의 역할을 대신함 )
## 3. 테스트 프로그램 작성(파이프 클라이언트(명령))
  - 명령 ( 명령코드작성(서버에게 보냄), CreateFile로 열음 )
