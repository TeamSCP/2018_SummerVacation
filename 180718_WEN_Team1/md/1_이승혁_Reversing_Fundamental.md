

# Reversing Fundamental

**20180718 이승혁**

올해 1월 1일부터 하던 내용이지만 완성이 되지 않아서 다시 한번 발표하려고 합니다.



## - 목 차 -

**I.Structure**

**II.Register**

**III.Stack**

**IV.Potable Executive**

**V.Assembly**

**VI.Reversing**

------

## I.Structure

**Computer Basic Component**

<img width="1401" alt="screen shot 2018-07-18 at 9 57 25 pm" src="https://user-images.githubusercontent.com/40850499/42896424-d19e2f30-8af7-11e8-9e41-b10d2480df81.png">



컴퓨터의 기본적인 구성 요소는 위와 같이 **CPU, Memory, Hard Disk**입니다. 

실행 파일(.exe)은 기본적으로 하드 디스크에 저장되며 윈도우에서는 **PE(Portable Executable)**라고 부릅니다. PE 파일에는 프로그램을 실행하는데 필요한 기본 정보와 파일을 메모리 어디에 저장해야 할 지 알려주는 배치 정보가 들어있습니다. PE 파일은 헤더(Header)와 바디(Body)로 구성되는데 헤더에는 앞서 말한 중요 정보들이 들어있고, 바디에는 코드와 데이터가 들어있습니다. PE에는 exe, dll, ocx 등 다양한 종류가 있지만 여기서는 exe만 다루도록 하겠습니다.

PE 포맷(헤더 + 바디)으로 구성된 실행 파일을 클릭하면 운영 체제에 있는 로더(Loader)가 헤더에 있는 정보를 분석해 PE 바디에 있는 코드와 데이터를 메모리에 배치합니다. 메모리는 프로그램 코드가 들어가는 코드 영역, 정적 변수와 전역 변수가 들어가는 데이터 영역, 함수 호출 시 사용되는 매개 변수와 지역 변수가 저장되는 스택 영역 그리고 동적 메모리  할당에 사용되는 힙 영역으로 구성됩니다. PE 파일이 메모리에 로딩 될 때는 코드 영역과 데이터 영역에 자료가 들어갑니다. 프로그램이 실행되면서 스택 영역과 힙 영역에 데이터가 쌓이게 됩니다.

PE 파일의 시작 지점은 정해져 있는데 그 지점을 **엔트리 포인트(Entry Point)**라고 부릅니다. 운영체제는 메모리에 있는 PE 파일을 실행시키기 위해 PE 헤더의 정보에서 엔트리 포인트 위치를 찾아 그곳부터 프로그램을 시작합니다.

프로그램 안의 명령어를 실행하는 것은 CPU 안의 제어장치(Control Unit)와 연산장치(ALU)입니다. 하지만 제어장치와 연산장치가 프로그램을 실행하는 데 필요한 데이터는 모두 메모리 안에 있어야 합니다. 따라서 메모리 안의 데이터를 레지스터로 복사하는 과정이 필요합니다.

컴퓨터는 하나의 CPU를 가지고 동시에 여러 가지 프로그램을 실행시켜야 하기 때문에 여러 프로그램이 번갈아가며 CPU를 사용합니다. 각 프로그램들은 CPU 사용이 끝나면 다른 프로그램에 사용 권한을 넘겨주며 자신이 사용하던 모든 레지스터를 메모리 영역으로 복사해둡니다. 이것을 컨텍스트 스위칭(Context Switching)이라고 합니다.



------

## II.Register

**Intel x86 CPU(IA-32)**

레지스터는 CPU에서 사용하는 고속기억장치 입니다. CPU는 연산을 수행하기 위해 메모리에 있는 데이터를 CPU 내부에 있는 레지스터를 가지고 오며 연산 중간에도 레지스터에 데이터를 저장합니다.

Intel x86 CPU의 기본 구조인 IA-32 아키텍처에서는 프로그램에서 사용하는 EAX, EBX, ECX, EDX, ESI, EDI, EBP, ESP 레지스터와 운영체제에서 사용하는 EIP. 이렇게 9개의 범용 레지스터를 제공합니다. 이외에도 다양한 레지스터를 제공하고 있지만, 리버싱을 할 때는 범용 레지스터를 중점적으로 살펴봐야 합니다. 

<img width="1026" alt="screen shot 2018-07-18 at 9 58 24 pm" src="https://user-images.githubusercontent.com/40850499/42896425-d1ffdd84-8af7-11e8-9ab6-bac5f34d8845.png">

> **EAX(Extended Accumulator Register)**
>
>  곱셈과 나눗셈 명령에서 사용되며, 함수의 반환값을 저장합니다.
>
> 
>
> **EBX(Extended Base Register)**
>
> ESI나 EDI와 결합해 인덱스에 사용됩니다.
>
> 
>
> **ECX(Extended Counter Register)**
>
> 반복 명령어를 사용할 때 반복 카운터를 저장합니다. ECX 레지스터에 반복할 횟수를 지정해 두고 반복 작업을 수행합니다.
>
> 
>
> **EDX(Extended Data Register)**
>
> EAX와 같이 사용되며 부호 확장 명령 등에 활용됩니다.
>
> 
>
> **ESI(Extended Source Index)**
>
> 데이터를 복사하거나 조작할 때 소스 데이터 주소가 저장됩니다. ESI 레지스터가 가리키는 주소에 있는 데이터를 EDI 레지스터가 가리키는 주소로 복사하는 용도로 많이 사용됩니다.
>
> 
>
> **EDI(Extended Destination Index)**
>
> 복사 작업을 할 때 목적지 주소가 저장됩니다. 주로 ESI 레지스터가 가리키는 주소의 데이터가 복사됩니다.
>
> 
>
> **EBP(Extended Base Pointer)**
>
> 하나의 스택 프레임의 시작 주소가 저장됩니다. 현재 사용되는 스택 프레임이 살아있는 동안 EBP의 값은 변하지 않습니다. 현재 사용한 스택 프레임이 사라지면 이전에 사용되었던 스택 프레임을 가리키게 됩니다.
>
> 
>
> **ESP(Extended Stack Pointer)**
>
> 하나의 스택 프레임의 끝 지점 주소가 저장됩니다. PUSH, POP 명령어에 따라서 ESP의 값이 4바이트씩 변하게 됩니다.
>
> 
>
> **EIP(Extended Instruction Pointer)**
>
> 다음에 실행할 명령어가 저장된 메모리 주소가 저장됩니다. 현재 명령어를 모두 실행한 다음에 EIP 레지스터에 저장된 주소에 있는 명령어를 실행합니다. 실행 전에 EIP 레지스터에는 다음에 실행해야 할 명령어가 있는 주솟값이 저장됩니다.



**E**

32비트 레지스터는 용도에 따라서 8비트 단위로 나누어 사용할 수 있습니다. EAX 레지스터는 하위 16비트만 AX라는 이름으로 사용할 수 있습니다. 또한 8비트 단위로 상위 8비트는 AH 레지스터, 하위 8비트는 AL 레지스터라는 이름으로 사용할 수 있습니다.

------

## III.Stack

**Stack and Stack Frame**

**스택(Stack)**은 메모리의 한 부분으로, **LIFO(Last Input First Output)** 방식으로 동작하는 특별한 자료 구조입니다. LIFO란 가장 마지막에 들어간 데이터가 가장 처음에 나오는 방식을 말합니다. 스택은 POP과 PUSH 두 가지 동작을 지원합니다. PUSH는 데이터를 스택에 집어넣는 명령어이고 POP은 데이터를 스택에서 꺼내는 동작을 합니다. 프로그램은 이 두 개의 명령어를 이용해 스택을 제어합니다.

<img width="1090" alt="screen shot 2018-07-19 at 2 12 47 am" src="https://user-images.githubusercontent.com/40850499/42904693-c4b36006-8b10-11e8-91ca-5cfd791764f6.png">mg width="793" alt="screen shot 2018-07-18 at 10 01 49 pm" src="https://user-images.githubusercontent.com/40850499/42896430-d2dfbf26-8af7-11e8-9205-b97058436455.png">

스택에는 한 방향으로만 데이터가 쌓이는데, PUSH를 하면 스택의 주소는 4바이트만큼 감소하면서 데이터가 스택으로 들어갑니다. POP을 하면 스택으로부터 데이터가 꺼내지고 스택의 주소는 다시 4바이트만큼 증가하게 됩니다. 스택은 시작 주소에서 주소가 작아지는 방향으로 데이터가 쌓이게 되는데, 이렇게 설계된 이유는 스택 구조 위에 있는 데이터가 시스템을 운영하는 데 있어서 중요한 역할을 하기 때문입니다.

현재 프로그램이 사용하는 스택의 위치는 스택 포인터라고 불리는 ESP 레지스터에 저장되어 있습니다. 스택에 값을 PUSH하거나 스택으로부터 데이터를 POP하면 ESP 레지스터의 값이 4바이트 만큼 증감하는 것을 확인할 수 있습니다. 

프로그램에서 스택은 서브루틴(함수)으로 인자를 전달하고, 서브루틴 내부에서 사용하는 지역 변수가 저장되는 공간을 제공하며, 서브루틴이 종료될 때 되돌아갈 주소를 저장하는 역할을 합니다. 운영체제는 이러한 메커니즘을 서브루틴이 호출되고 종료될 떄 정교하게 제어하고 있습니다. 디버거로 어셈블러를 분석해 보면 함수를 호출할 때 정확하게 인자를 스택으로 PUSH하고 서브루틴이 종료될 때 복귀 주소를 스택에서 POP하는 것을 확인할 수 있습니다.

스택의 동작 방식을 이해하지 못하면 리버싱을 이해할 수 없으므로 리버싱을 할 때는 스택의 기본 개념을 반드시 이해하고 있어야 합니다.



**스택 프레임(Stack Frame)**은 서브루틴(함수)이 가지는 자신만의 스택 영역입니다. 스택 프레임에는 서브루틴 내부에서 사용하는 데이터가 저장됩니다. 함수가 호출될 때 스택 프레임이 생성되며, 함수가 동작을 종료하고 복귀 주소로 돌아갈 때 스택 프레임은 소멸합니다.

<img width="793" alt="screen shot 2018-07-18 at 10 01 49 pm" src="https://user-images.githubusercontent.com/40850499/42905223-55873ec6-8b12-11e8-9313-ffea4fe810d3.png">

서브루틴을 호출할 때 필요한 인자들을 먼저 스택으로 입력합니다. 서브루틴을 실행하기 바로 직전에 운영체제는 다시 돌아올 주소인 복귀 주소를 스택으로 집어넣습니다. 이제부터 스택 프레임이 생성됩니다. 처음에 이전 루틴이 사용했던 EBP 레지스터 내영을 백업합니다. EBP 레지스터가 백업된 위치의 스택 주소를 서브루틴의 EBP에 다시 집어넣습니다. 이렇게 설정된 EBP는 스택 프레임에서 데이터 참조를 위한 기준 주소인 프레임 포인터(Frame Pointer)로 사용됩니다.

스택에 있는 데이터를 접근할 때 프레임 포인터를 사용하는 이유는 ESP 레지스터는 프로그램이 실행되면서 계속 변하기 때문에 변하지 않는 EBP를 사용해서 스택에 있는 데이터에 접근하려는 것입니다.

------

## IV.Portable Executable

**Basic Concept of PE File**

<img width="1257" alt="screen shot 2018-07-18 at 10 03 14 pm" src="https://user-images.githubusercontent.com/40850499/42896431-d33c8198-8af7-11e8-8dc3-c0caf65b363b.png">

일반적으로 우리가 사용하는 소프트웨어는 Visual C++, Visual Basic, Java와 같은 고급 언어로 만들어집니다. 하지만, 프로그램을 실행하는 운영체제는 고급  언어를 이해할 수 없기 때문에 고급 언어를 기계어로 번역해 주어야 하는데, 이러한 기능을 담당하는 것이 바로 컴파일러(Compiler)입니다. 기계어는 파일로 만들어지는데, EXE나 DLL 같은 확장자로 만들어 집니다. 이러한 파일을 PE(Portable Executable) 파일이라고 부릅니다.

PE 파일은 PE 포맷에 따라서 만들어야 합니다. PE 포맷은 윈도우에서 만든 프로그램이 실행되기 위해 준수해야 하는 일종의 규칙입니다. 이 규칙을 지키지 않는 프로그램은 올바로 실행되지 않습니다. 리버싱은 기계어로 구성된 실행 파일을 분석해 동작을 알아내는 과정이기 때문에 리버서는 반드시 PE 포맷에 대해 자세히 알아야 합니다.

| 종류               | 주요 확장자        |
| ------------------ | ------------------ |
| 실행 계열          | EXE, SCR           |
| 라이브러리 계열    | DLL, OCX, CPL, DRV |
| 드라이버 계열      | SYS, VXD           |
| 오브젝트 파일 계열 | DBJ                |

PE란 윈도우 운영체제에서 사용하는 실행 파일 형식입니다. 윈도우에서 프로그램을 개발하고 실행 파일로 컴파일(Compile)하면 PE 형식으로 만들어집니다. 윈도우에서 사용하는 실행 파일에는 EXE, DLL, OCX, SYS 등 다양한 종류가 있습니다.

<img width="1245" alt="screen shot 2018-07-18 at 10 03 38 pm" src="https://user-images.githubusercontent.com/40850499/42896432-d38a6b60-8af7-11e8-97af-4a0583d6dcaa.png">

PE 파일 헤더와 바디로 구성되고, 헤더는 PE 파일이 어떻게 동작해야 하는지에 대한 규칙을 담고있습다. 바디는 헤더에 적혀있는 규칙에 따라 실행되는 기계어들이 저장되어 있습니다.

![Screen Shot 2018-07-18 at 10.08.21 PM](/Users/lsh/Desktop/Screen Shot 2018-07-18 at 10.08.21 PM.png)

PE 파일은 PE 헤더(Header), 섹션 헤더(Section Header) 그리고 섹션 데이터(Section Data)로 구성됩니다. 특히 PE 헤더와 섹션 헤더를 PE 헤더라고 통칭하기도 합니다. 모든 윈도우 PE 파일 공통으로 PE 헤더(IMAGE_DOS_HEADER, MS-DOS Stub Program, IMAGE_NT_HEADERS)를 가지고 있습니다. 섹션 헤더 부분은 PE 파일마다 가지는 내용과 형태가 다르며, PE 파일은 최소 한 개 이상의 섹션 헤더를 가지고 있습니다. 섹션 데이터 영역 역시 PE 파일마다 가지는 내용과 형태가 다르며 최소 한 개 이상의 섹션 데이터 영역이 있습니다. 

PE 파일은 헤더와 데이터 부분으로 나뉘며 , 헤더에는 파일 구성에 관련된 정보가 들어있고 데이터 부분에는 프로그램에서 사용되는 코드와 프로그램이 사용하는 데이터가 들어가 있습니다.

**IMAGE_DOS_HEADER**는 DOS 운영체제가 윈도우용 PE 파일을 실행했을 때 적절한 오류 메시지를 보여주며, 실제 윈도우용 PE 헤더 위치를 가리키는 역할을 합니다. **MS-DOS Stub Program**은 DOS 운영체제에서 윈도우용 PE 파일을 실행했을 때 보여줄 오류 메시지를 저장하고 있습니다. PE 파일 내부에는 이처럼 오류 처리를 위한 작은 DOS 프로그램이 내장되어 있습니다.

**IMAGE_NT_HEADERS**는 4바이트 Signature와 2개의 IMAGE_FILE_HEADER, IMAGE_OPTIONAL_HEADER 구조체로 구성되어 있습니다. IMAGE_FILE_HEADER와 IMAGE_OPTIONAL_HEADER 구조체는 PE 파일에서 핵심적인 역할을 하기 때문에 유심히 살펴봐야 합니다.  IMAGE_OPTIONAL_HEADER 궂체 뒤에는 중요한 역할을 담당하는 16개의 IMAGE_DATA_DIRECTORY 구조체가 따라옵니다.

**IMAGE_OPTIONAL_HEADER**는 PE 구조에서 핵심적인 역할을 한다. 많은 항목이 있지만 중요한 내용을 중심으로 살펴보겠습니다. 'Image Base'는 메모리에 PE 파일이 저장되는 시작 주소입니다. PE 파일에서 확인할 수 있는 RVA(Relative Virtual Address)는 메모리에 로딩되면서 'Image Base'값과 합산된 주소(VA: Virtual Address)에 저장됩니다. 'Address of Entry Point'는 프로그램 실행에 대한 제어권이 커널 영역에서 코드 영역으로 처음 넘어오는 주소인 엔트리 포인트를 가리킵니다. 'Base of Code'는 코드 영역이 시작되는 주소(RVA)를 가리킵니다. 디버거로 프로그램을 열었을 때 코드 영역의 맨 윗 부분 주소에 해당합니다.



**주소 지정 방법**

PE 파일을 분석할 때 내가 찾는 데이터가 어디에 위치해 있는지는 헤더에 있는 정보를 가지고 찾을 수 있습니다. 이때 사용하는 값이 주소인데, 크게 세 종류의 주소 형식을 사용하고 있습니다. 하나는 pFile로, PE 파일 내부에서의 오프셋 값을 의미합니다. RVA(Relative Virtual Address)로, 이것은 PE 파일이 메모리로 로드됐을 때 저장되는 상대 주소를 의미합니다. 여기서 상대 주소라는 말은 특정 값을 기준으로 얼마나 떨어져 있는지를 나타내는 것입니다. 마지막 하나는 VA(Virtual Address)인데 이것은 가상 메모리상에서 저장되는 실제 주소를 나타냅니다.

> - pFile : PE 파일 내부에서의 오프셋(파일)
> - RVA : 메모리에 로드됐을 때, 기준값에서 얼마나 떨어져 있는지를 나타내는 상대 위치(메모리)
> - VA : 가상 메모리상에 저장되는 실제 주소(메모리)

pFile은 PE 파일이 물리적으로 하드디스크에 저장되었을 때 의미 있는 값이며, VA와 RVA는 PE 파일이 메모리에 로드됐을 때 의미있는 값입니다.

윈도우에서는 DLL(Dynamic Linking Library)이라는 개념을 사용하고 있습니다. 말 그대로 프로그램에서 필요한 라이브러리를 사용 시점에 동적으로 연결한다는 뜻입니다. 예전에는 프로그램이 컴파일 시점에 필요한 모든 기능을 실행 파일 안에 집어넣었지만, 시스템에 지원하는 기능이 다양해지고 부피가 커짐에 따라서 이러한 방식은 비효율적인 것이 되었습니다. PE 파일에는 DLL을 사용할 수 있도록 지원하는 IAT 정보가 포함되어 있습니다.



**IAT(Import Address Table)**

IAT는 실행 파일(PE 파일) 안에 어떤 라이브러리의 어떤 함수를 가져다 쓰는지 기록해놓은 정보입니다. 로더는 PE 파일을 메모리로 로딩할 때 IAT에 기록된 API 이름을 참조해서 실제 주소를 찾아 IAT 안에 API를 가리키는 주소를 적어 놓습니다. 코드에서 라이브러리를 참조하는 부분은 IAT 내부에 있는 함수 주소를 사용하고 있습니다.

------

## V.Assembly

**Short Assembly Example** 

어셈블리어의 명령어는 이 문서에서 다루기에는 양이 너무 많기 때문에 예제를 가져와 명령어의 일부만 보여드리도록 하겠습니다. 

[Download Example](http://www.hunterhacker.xpg.com.br/fergo_ex1.zip)

![picture1](https://user-images.githubusercontent.com/40850499/42907873-20219328-8b1a-11e8-802c-90907ed51c00.png)

**Line 1** : SUB EAX, EAX

SUB는 뺄셈 명령이고 두 개의 인자를 필요로 합니다. EAX는 비교할 값을 일시적으로 저장해 두는 일 등을 하는 레지스터입니다. 이 명령은  두 번째 인자에서 첫 번째 인자를 뺀 값을 출력합니다. EAX = EAX - EAX와 같은 것은 ASM에서 값을 0으로 만드는 가장 흔한 방법 중 하나입니다. 

**Line 2** : CMP EAX, 0

CMP는 “to CoMPare”라는 뜻입니다. 이 명령은 첫 번째와 두 번째 인자를 서로 비교 연산하고 만약 성공적으로 연산을 수행했다면  제로 플래그를 마크합니다(Immunity debugger등에서 볼 수 있습니다). 예시처럼 EAX를 0과 비교할 때(C언어에서 if (eax ==0) 등) 마지막 줄에 결과 0이 레지스터 EAX에 들어가고 0과 비교하게 되여 연산 결과는 참이 됩니다. 

**Line 3** : JE SHORT fergo_ex.00401015 

같으면 점프한다는 뜻입니다. 뜻이 말해주듯이 만약 연산에서의 인자들이 동일하다면(참이라면) 다른 코드 부분으로 점프하게 됩니다. 위의 예시에서는 연산이 참이므로 프로그램은 fergo_ex1.exe 실행파일 내의 00401015 주소로 점프하게 됩니다. 그래서 4, 5, 6번째 줄의 내용은 후술하도록 하겠습니다.

**Line 7** : LEA EAX, DWORD PTR DS:[403000] 

LEA(Load Effective Address) 명령은 첫 번째 인자에 두 번째 인자의 주소값을 입력해줍니다. 이것은 "값" 을 받는것이 아니라 값이 저장된 "주소"를 받아옵니다. 위의 예시와 같은 경우에는 EAX 레지스터에 403000을 넣어줍니다. (DWORD : 32 bits value) 

**Line 8** : LEA EBX,DWORD PTR DS:[403009] 

위와 같은 내용이며 차이점은 주소와 변수가 다르다는 점입니다.

**Line 9** : PUSH 0

위의 스택 부분에서 보았듯 인자(0)을 일시적으로 메모리에 저장(스택)하는 것입니다. 이것은 다른 명령과는 조금 다릅니다.

**Line 10, 11, 12** : PUSH ...

9번 줄과 같습니다 차이점은 스택에 PUSH 하는 값이 다르다는 것입니다. 다르게 말하면 EAX, EBX 등의 값을 넣는 곳이라는 것입니다. 

![picture1](https://user-images.githubusercontent.com/40850499/42907542-0f210cb2-8b19-11e8-8984-5f9e478e7ffc.png)

**Line 13** : CALL <JMP.&user32.MessageBoxA>

함수를 호출합니다. 위의 경우에는 user32.dll에 포함되어 있는 MessageBoxA 함수를 호출하는 명령입니다. 이 함수는 메시지 박스 안에 있는 메시지를 보여주기 위해 사용되며, 이 메시지의 경우에는 프로그램을 시작할 때 메시지를 보여줍니다.

> MessageBoxA ( Owner, Address of text, endereço do título, Type )  

Owner는 대화 박스의 주인을 나타냅니다.

Address of text는 윈도우 타이틀의 주소입니다.

Type은 메시지의 타입 입니다(button OK/Cancel, Yes/No, etc...).

이 함수는 ASM으로 되어있으며, 스택에 PUSH된 인자들을 역순으로 가져옵니다. 예를 들어 Owner는 00401025에 위치하고 있고, 텍스트는 \00401024에 있습니다. 각각의 PUSH는 스택에 데이터를 넣습니다. 그 데이터를 얻기 위해서는 역순으로 시작하는 것이 필요합니다.  

**Line 14** : PUSH 0

새로운 값이 스택에 들어갑니다.

**Line 15** : CALL <JMP.&kernel32.ExitProcess> 

ExitProcess 함수를 호출합니다. 이 함수는 프로그램의 실행을 끝내는 용도로 사용됩니다. 이 함수의 인자는 상태를 나타내는 숫자로, 프로그램이 성공했는지 그렇지 못한지 판별합니다. 프로그램에서 볼 수 있듯이 OK를 누르면 프로그램은 닫힙니다. 이 명령 이전에 스택에 0을 넣는데, 이것은 이 함수가 0을 받는다는 뜻 입니다. 0을 받은 함수는 프로그램을 종료하게 됩니다.

**Line 7, 8**  : LEA ...

프로그램이 EAX와 EBX에 값을 입력합니다. 이 값들은 프로그램이 종료되기 전에 각 레지스터의 값을 확정하고 그 뒤에 각 레지스터의 값을  텍스트와 메시지 박스의 타이틀로 PUSH 합니다.

**Line 4, 5** : Other LEA...

이 두 줄에는 LEA 명령이 있습니다. 이 LEA들은 EAX와 EBX를 변경하는 기능이 있지만 **Line 3**의 점프로 인해 작동하지 않습니다.

**SOLUTION**

이 프로그램에서 점프를 NOP(0x90)으로 바꾸어 점프를 하지 않게 만들면 메시지 박스를 볼 수 있습니다.

------

## VI.Reversing

**SEQUENCE**

